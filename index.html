<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto FDV Estimator</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js v4 -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <!-- Chart.js Datalabels Plugin -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0/dist/chartjs-plugin-datalabels.min.js"></script>
    <style>
        .gradient-bg {
            background: linear-gradient(135deg, #eff6ff 0%, #e0e7ff 100%);
        }
        .log-entry {
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 12px;
        }
        .log-info { color: #3b82f6; }
        .log-success { color: #22c55e; }
        .log-warning { color: #f59e0b; }
        .log-error { color: #ef4444; }
        .log-calc { color: #8b5cf6; }
    </style>
</head>
<body class="gradient-bg min-h-screen py-8 px-4">
    <div class="max-w-7xl mx-auto">
        <!-- Header -->
        <div class="text-center mb-8">
            <h1 class="text-4xl font-bold text-gray-800 mb-2">üìä Crypto FDV Estimator</h1>
            <p class="text-gray-600">Estimation de la Fully Diluted Valuation bas√©e sur les revenus</p>
        </div>

        <!-- Controls -->
        <div class="bg-white rounded-xl shadow-lg p-6 mb-6">
            <div class="flex flex-wrap items-center justify-between gap-4">
                <div>
                    <span class="text-sm text-gray-500">Derni√®re mise √† jour :</span>
                    <span id="lastUpdate" class="text-sm font-medium text-gray-700">-</span>
                </div>
                <button id="refreshBtn" onclick="loadAllData()" 
                    class="bg-indigo-600 hover:bg-indigo-700 text-white font-medium py-2 px-6 rounded-lg transition-colors flex items-center gap-2">
                    <svg id="refreshIcon" class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                    </svg>
                    <span id="refreshText">Actualiser les donn√©es</span>
                </button>
            </div>
            <!-- Loading Progress -->
            <div id="loadingProgress" class="hidden mt-4">
                <div class="flex items-center gap-3">
                    <div class="animate-spin rounded-full h-5 w-5 border-b-2 border-indigo-600"></div>
                    <span id="loadingText" class="text-sm text-gray-600">Chargement...</span>
                </div>
                <div class="mt-2 bg-gray-200 rounded-full h-2">
                    <div id="progressBar" class="bg-indigo-600 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
                </div>
            </div>
        </div>

        <!-- Chart -->
        <div class="bg-white rounded-xl shadow-lg p-6 mb-6">
            <h2 class="text-xl font-semibold text-gray-800 mb-4">Graphique Revenu vs FDV (√âchelle Logarithmique)</h2>
            <div class="relative" style="height: 500px;">
                <canvas id="scatterChart"></canvas>
            </div>
            <div class="flex gap-6 mt-4 justify-center">
                <div class="flex items-center gap-2">
                    <div class="w-4 h-4 rounded-full bg-blue-500"></div>
                    <span class="text-sm text-gray-600">Token Live</span>
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-4 h-4 rounded-full bg-orange-500"></div>
                    <span class="text-sm text-gray-600">FDV Estim√©e</span>
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-3 h-0.5 bg-orange-500 border-dashed border-t-2 border-orange-500"></div>
                    <span class="text-sm text-gray-600">R√©gression pond√©r√©e</span>
                </div>
            </div>
        </div>

        <!-- Data Table -->
        <div class="bg-white rounded-xl shadow-lg p-6 mb-6 overflow-x-auto">
            <h2 class="text-xl font-semibold text-gray-800 mb-4">Tableau des Donn√©es</h2>
            <table class="w-full">
                <thead>
                    <tr class="border-b-2 border-gray-200">
                        <th class="text-left py-3 px-4 cursor-pointer hover:bg-gray-50" onclick="sortTable('name')">
                            Projet <span id="sort-name" class="text-gray-400">‚Üï</span>
                        </th>
                        <th class="text-right py-3 px-4 cursor-pointer hover:bg-gray-50" onclick="sortTable('fees7d')">
                            Moy. 7j <span id="sort-fees7d" class="text-gray-400">‚Üï</span>
                        </th>
                        <th class="text-right py-3 px-4 cursor-pointer hover:bg-gray-50" onclick="sortTable('annualRevenue')">
                            Revenu Annuel <span id="sort-annualRevenue" class="text-gray-400">‚Üï</span>
                        </th>
                        <th class="text-right py-3 px-4 cursor-pointer hover:bg-gray-50" onclick="sortTable('fdv')">
                            FDV <span id="sort-fdv" class="text-gray-400">‚Üï</span>
                        </th>
                        <th class="text-right py-3 px-4 cursor-pointer hover:bg-gray-50" onclick="sortTable('ratio')">
                            Ratio <span id="sort-ratio" class="text-gray-400">‚Üï</span>
                        </th>
                        <th class="text-center py-3 px-4 cursor-pointer hover:bg-gray-50" onclick="sortTable('hasToken')">
                            Statut <span id="sort-hasToken" class="text-gray-400">‚Üï</span>
                        </th>
                    </tr>
                </thead>
                <tbody id="dataTable">
                    <tr>
                        <td colspan="6" class="text-center py-8 text-gray-500">
                            Chargement des donn√©es...
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>

        <!-- Debug Logs -->
        <div class="bg-white rounded-xl shadow-lg mb-6">
            <button onclick="toggleLogs()" class="w-full p-4 text-left flex items-center justify-between hover:bg-gray-50 rounded-xl">
                <span class="font-semibold text-gray-800">üîß Logs de Debug</span>
                <svg id="logsArrow" class="w-5 h-5 text-gray-500 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                </svg>
            </button>
            <div id="logsContainer" class="hidden border-t border-gray-200">
                <div class="p-4 max-h-96 overflow-y-auto bg-gray-900 rounded-b-xl">
                    <pre id="logs" class="log-entry text-gray-300 whitespace-pre-wrap"></pre>
                </div>
            </div>
        </div>

        <!-- Footer -->
        <div class="text-center text-gray-500 text-sm">
            <p>Donn√©es fournies par DeFiLlama & CoinGecko</p>
            <p class="mt-1">Actualisation automatique toutes les 24h</p>
        </div>
    </div>

    <script>
        // =====================================================
        // CONFIGURATION DES PROJETS
        // =====================================================
        const PROJECTS = {
            // Projets avec token (slug DeFiLlama / id CoinGecko)
            withToken: [
                { name: 'Hyperliquid', llamaSlug: 'hyperliquid', coingeckoId: 'hyperliquid' },
                { name: 'Lighter', llamaSlug: 'lighter', coingeckoId: 'lighter' },
                { name: 'Aster', llamaSlug: 'aster', coingeckoId: 'aster-2' },
                { name: 'dYdX', llamaSlug: 'dydx', coingeckoId: 'dydx-chain' },
                { name: 'Avantis', llamaSlug: 'avantis', coingeckoId: 'avantis' },
                { name: 'Orderly', llamaSlug: 'orderly', coingeckoId: 'orderly-network' },
                { name: 'GMX', llamaSlug: 'gmx', coingeckoId: 'gmx' },
                { name: 'Drift', llamaSlug: 'drift', coingeckoId: 'drift-protocol' },
            ],
            // Projets sans token (FDV estim√©e)
            withoutToken: [
                { name: 'Extended', llamaSlug: 'extended' },
                { name: 'Paradex', llamaSlug: 'paradex' },
                { name: 'EdgeX', llamaSlug: 'edgex' },
                { name: 'Ethereal', llamaSlug: 'ethereal-dex' },
                { name: 'Ostium', llamaSlug: 'ostium' },
                { name: 'Unit', llamaSlug: 'unit' },
                { name: 'tradeXYZ', llamaSlug: 'tradexyz' },
                { name: 'GRVT', llamaSlug: 'grvt' },
                { name: 'Reya', llamaSlug: 'reya' },
            ]
        };

        // =====================================================
        // VARIABLES GLOBALES
        // =====================================================
        let projectsData = [];
        let currentSort = { column: 'hasToken', direction: 'desc' };
        let chart = null;

        // =====================================================
        // FONCTIONS UTILITAIRES
        // =====================================================
        
        // Formatage des nombres en USD avec B/M/K
        function formatUSD(value) {
            if (value === null || value === undefined || isNaN(value)) return '-';
            if (value >= 1e9) return '$' + (value / 1e9).toFixed(2) + 'B';
            if (value >= 1e6) return '$' + (value / 1e6).toFixed(2) + 'M';
            if (value >= 1e3) return '$' + (value / 1e3).toFixed(2) + 'K';
            return '$' + value.toFixed(2);
        }

        // Formatage du ratio
        function formatRatio(value) {
            if (value === null || value === undefined || isNaN(value) || !isFinite(value)) return '-';
            return value.toFixed(1) + 'x';
        }

        // Ajouter un log
        function addLog(message, type = 'info') {
            const logsEl = document.getElementById('logs');
            const timestamp = new Date().toLocaleTimeString('fr-FR');
            const colorClass = {
                info: 'log-info',
                success: 'log-success',
                warning: 'log-warning',
                error: 'log-error',
                calc: 'log-calc'
            }[type] || 'log-info';
            
            logsEl.innerHTML += `<span class="${colorClass}">[${timestamp}] ${message}</span>\n`;
            logsEl.scrollTop = logsEl.scrollHeight;
        }

        // Basculer l'affichage des logs
        function toggleLogs() {
            const container = document.getElementById('logsContainer');
            const arrow = document.getElementById('logsArrow');
            container.classList.toggle('hidden');
            arrow.classList.toggle('rotate-180');
        }

        // =====================================================
        // APPELS API
        // =====================================================
        
        // R√©cup√©rer les fees depuis DeFiLlama via notre Edge Function
        async function fetchFees(protocol) {
            try {
                addLog(`üì° Appel API fees pour: ${protocol}`, 'info');
                const response = await fetch(`/api/fees?protocol=${encodeURIComponent(protocol)}`);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const data = await response.json();
                
                if (data.error) {
                    throw new Error(data.error);
                }
                
                addLog(`‚úÖ Fees ${protocol}: 24h=${formatUSD(data.total24h)}, 7d=${formatUSD(data.total7d)}`, 'success');
                return data;
            } catch (error) {
                addLog(`‚ùå Erreur fees ${protocol}: ${error.message}`, 'error');
                return null;
            }
        }

        // R√©cup√©rer la FDV depuis CoinGecko via notre Edge Function
        async function fetchFDV(coinId) {
            try {
                addLog(`üì° Appel API CoinGecko pour: ${coinId}`, 'info');
                const response = await fetch(`/api/coingecko?coinId=${encodeURIComponent(coinId)}`);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const data = await response.json();
                
                if (data.error) {
                    throw new Error(data.error);
                }
                
                addLog(`‚úÖ FDV ${coinId}: ${formatUSD(data.fdv)}, MC=${formatUSD(data.marketCap)}`, 'success');
                return data;
            } catch (error) {
                addLog(`‚ùå Erreur CoinGecko ${coinId}: ${error.message}`, 'error');
                return null;
            }
        }

        // =====================================================
        // R√âGRESSION LIN√âAIRE POND√âR√âE
        // =====================================================
        
        function calculateWeightedRegression(data) {
            // Filtrer les projets avec token et donn√©es valides
            const validData = data.filter(p => p.hasToken && p.annualRevenue > 0 && p.fdv > 0);
            
            if (validData.length < 2) {
                addLog('‚ö†Ô∏è Pas assez de donn√©es pour la r√©gression (min 2 projets avec token)', 'warning');
                return null;
            }

            addLog(`üìä Calcul de r√©gression pond√©r√©e avec ${validData.length} projets`, 'calc');

            // Utiliser le log pour la r√©gression (car √©chelle log)
            const logData = validData.map(p => ({
                x: Math.log10(p.annualRevenue),
                y: Math.log10(p.fdv),
                weight: p.annualRevenue // Poids = revenu du projet
            }));

            // Normaliser les poids
            const totalWeight = logData.reduce((sum, d) => sum + d.weight, 0);
            logData.forEach(d => d.weight = d.weight / totalWeight);

            // R√©gression pond√©r√©e: y = a*x + b
            let sumWX = 0, sumWY = 0, sumWXX = 0, sumWXY = 0, sumW = 0;
            
            logData.forEach(d => {
                sumW += d.weight;
                sumWX += d.weight * d.x;
                sumWY += d.weight * d.y;
                sumWXX += d.weight * d.x * d.x;
                sumWXY += d.weight * d.x * d.y;
            });

            const denominator = sumW * sumWXX - sumWX * sumWX;
            if (Math.abs(denominator) < 1e-10) {
                addLog('‚ö†Ô∏è Erreur de calcul de r√©gression (d√©nominateur nul)', 'warning');
                return null;
            }

            const a = (sumW * sumWXY - sumWX * sumWY) / denominator;
            const b = (sumWY * sumWXX - sumWX * sumWXY) / denominator;

            addLog(`üìà R√©gression: log(FDV) = ${a.toFixed(4)} * log(Revenue) + ${b.toFixed(4)}`, 'calc');
            addLog(`üìà √âquivalent: FDV = 10^${b.toFixed(2)} * Revenue^${a.toFixed(2)}`, 'calc');

            return { a, b };
        }

        // Estimer la FDV bas√©e sur le revenu
        function estimateFDV(annualRevenue, regression) {
            if (!regression || annualRevenue <= 0) return null;
            const logRevenue = Math.log10(annualRevenue);
            const logFDV = regression.a * logRevenue + regression.b;
            return Math.pow(10, logFDV);
        }

        // =====================================================
        // CHARGEMENT DES DONN√âES
        // =====================================================
        
        async function loadAllData() {
            const refreshBtn = document.getElementById('refreshBtn');
            const refreshIcon = document.getElementById('refreshIcon');
            const refreshText = document.getElementById('refreshText');
            const loadingProgress = document.getElementById('loadingProgress');
            const loadingText = document.getElementById('loadingText');
            const progressBar = document.getElementById('progressBar');
            
            // UI de chargement
            refreshBtn.disabled = true;
            refreshBtn.classList.add('opacity-50', 'cursor-not-allowed');
            refreshIcon.classList.add('animate-spin');
            refreshText.textContent = 'Chargement...';
            loadingProgress.classList.remove('hidden');
            
            // Effacer les logs pr√©c√©dents
            document.getElementById('logs').innerHTML = '';
            addLog('üöÄ D√©but du chargement des donn√©es...', 'info');
            
            projectsData = [];
            const allProjects = [
                ...PROJECTS.withToken.map(p => ({ ...p, hasToken: true })),
                ...PROJECTS.withoutToken.map(p => ({ ...p, hasToken: false }))
            ];
            
            const totalSteps = allProjects.length + PROJECTS.withToken.length;
            let currentStep = 0;

            // 1. R√©cup√©rer les fees pour tous les projets
            addLog('üì• √âtape 1: R√©cup√©ration des fees (DeFiLlama)...', 'info');
            
            for (const project of allProjects) {
                loadingText.textContent = `Chargement fees: ${project.name}...`;
                const feesData = await fetchFees(project.llamaSlug);
                
                const daily7dAvg = feesData?.total7d ? feesData.total7d / 7 : 0;
                const annualRevenue = daily7dAvg * 365;
                
                projectsData.push({
                    name: project.name,
                    llamaSlug: project.llamaSlug,
                    coingeckoId: project.coingeckoId || null,
                    hasToken: project.hasToken,
                    fees24h: feesData?.total24h || 0,
                    fees7d: feesData?.total7d || 0,
                    fees7dAvg: daily7dAvg,
                    annualRevenue: annualRevenue,
                    fdv: null,
                    fdvEstimated: false,
                    ratio: null,
                    logo: feesData?.logo || null
                });
                
                currentStep++;
                progressBar.style.width = `${(currentStep / totalSteps) * 100}%`;
                
                // Petite pause pour √©viter le rate limiting
                await new Promise(r => setTimeout(r, 100));
            }

            // 2. R√©cup√©rer les FDV pour les projets avec token
            addLog('üì• √âtape 2: R√©cup√©ration des FDV (CoinGecko)...', 'info');
            
            for (const project of PROJECTS.withToken) {
                loadingText.textContent = `Chargement FDV: ${project.name}...`;
                const fdvData = await fetchFDV(project.coingeckoId);
                
                const projectData = projectsData.find(p => p.llamaSlug === project.llamaSlug);
                if (projectData && fdvData) {
                    projectData.fdv = fdvData.fdv;
                    // Utiliser le logo CoinGecko si pas de logo DeFiLlama
                    if (!projectData.logo && fdvData.image) {
                        projectData.logo = fdvData.image;
                    }
                    if (projectData.fdv > 0 && projectData.annualRevenue > 0) {
                        projectData.ratio = projectData.fdv / projectData.annualRevenue;
                    }
                }
                
                currentStep++;
                progressBar.style.width = `${(currentStep / totalSteps) * 100}%`;
                
                // Petite pause pour √©viter le rate limiting
                await new Promise(r => setTimeout(r, 300));
            }

            // 3. Calculer la r√©gression et estimer les FDV
            addLog('üì• √âtape 3: Calcul des estimations...', 'info');
            loadingText.textContent = 'Calcul de la r√©gression...';
            
            const regression = calculateWeightedRegression(projectsData);
            
            // Appliquer les estimations aux projets sans token
            for (const project of projectsData) {
                if (!project.hasToken && project.annualRevenue > 0) {
                    const estimatedFDV = estimateFDV(project.annualRevenue, regression);
                    if (estimatedFDV) {
                        project.fdv = estimatedFDV;
                        project.fdvEstimated = true;
                        project.ratio = project.fdv / project.annualRevenue;
                        addLog(`üí° Estimation ${project.name}: FDV=${formatUSD(estimatedFDV)}, Ratio=${formatRatio(project.ratio)}`, 'calc');
                    }
                }
            }

            // Identifier les projets exclus
            const excluded = projectsData.filter(p => p.annualRevenue <= 0);
            if (excluded.length > 0) {
                addLog(`‚ö†Ô∏è Projets exclus du graphique (revenus ‚â§ 0): ${excluded.map(p => p.name).join(', ')}`, 'warning');
            }

            // 4. Mettre √† jour l'affichage
            addLog('üé® Mise √† jour de l\'interface...', 'info');
            updateTable();
            await updateChart(regression);
            
            // Mettre √† jour la date
            document.getElementById('lastUpdate').textContent = new Date().toLocaleString('fr-FR');
            
            // Reset UI
            refreshBtn.disabled = false;
            refreshBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            refreshIcon.classList.remove('animate-spin');
            refreshText.textContent = 'Actualiser les donn√©es';
            loadingProgress.classList.add('hidden');
            
            addLog('‚úÖ Chargement termin√©!', 'success');
        }

        // =====================================================
        // MISE √Ä JOUR DU TABLEAU
        // =====================================================
        
        function updateTable() {
            const tbody = document.getElementById('dataTable');
            
            // Tri des donn√©es
            const sortedData = [...projectsData].sort((a, b) => {
                let valA, valB;
                
                switch (currentSort.column) {
                    case 'name':
                        valA = a.name.toLowerCase();
                        valB = b.name.toLowerCase();
                        break;
                    case 'fees7d':
                        valA = a.fees7dAvg || 0;
                        valB = b.fees7dAvg || 0;
                        break;
                    case 'annualRevenue':
                        valA = a.annualRevenue || 0;
                        valB = b.annualRevenue || 0;
                        break;
                    case 'fdv':
                        valA = a.fdv || 0;
                        valB = b.fdv || 0;
                        break;
                    case 'ratio':
                        valA = a.ratio || 0;
                        valB = b.ratio || 0;
                        break;
                    case 'hasToken':
                        valA = a.hasToken ? 1 : 0;
                        valB = b.hasToken ? 1 : 0;
                        break;
                    default:
                        return 0;
                }
                
                if (typeof valA === 'string') {
                    return currentSort.direction === 'asc' 
                        ? valA.localeCompare(valB) 
                        : valB.localeCompare(valA);
                }
                
                return currentSort.direction === 'asc' ? valA - valB : valB - valA;
            });

            // G√©n√©rer le HTML du tableau
            tbody.innerHTML = sortedData.map(project => `
                <tr class="border-b border-gray-100 hover:bg-gray-50 transition-colors">
                    <td class="py-3 px-4">
                        <div class="flex items-center gap-2">
                            ${project.logo ? `<img src="${project.logo}" alt="${project.name}" class="w-6 h-6 rounded-full">` : ''}
                            <span class="font-medium text-gray-800">${project.name}</span>
                        </div>
                    </td>
                    <td class="text-right py-3 px-4 text-gray-600">${formatUSD(project.fees7dAvg)}</td>
                    <td class="text-right py-3 px-4 text-gray-600">${formatUSD(project.annualRevenue)}</td>
                    <td class="text-right py-3 px-4">
                        <span class="${project.fdvEstimated ? 'text-orange-600' : 'text-gray-800'} font-medium">
                            ${formatUSD(project.fdv)}${project.fdvEstimated ? '*' : ''}
                        </span>
                    </td>
                    <td class="text-right py-3 px-4 text-gray-600">${formatRatio(project.ratio)}</td>
                    <td class="text-center py-3 px-4">
                        ${project.hasToken 
                            ? '<span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800">‚úì Live</span>'
                            : '<span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-orange-100 text-orange-800">‚è≥ Estim√©</span>'
                        }
                    </td>
                </tr>
            `).join('');

            // Mettre √† jour les indicateurs de tri
            document.querySelectorAll('[id^="sort-"]').forEach(el => {
                el.textContent = '‚Üï';
                el.classList.remove('text-indigo-600');
                el.classList.add('text-gray-400');
            });
            
            const currentSortEl = document.getElementById(`sort-${currentSort.column}`);
            if (currentSortEl) {
                currentSortEl.textContent = currentSort.direction === 'asc' ? '‚Üë' : '‚Üì';
                currentSortEl.classList.remove('text-gray-400');
                currentSortEl.classList.add('text-indigo-600');
            }
        }

        function sortTable(column) {
            if (currentSort.column === column) {
                currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
            } else {
                currentSort.column = column;
                currentSort.direction = 'desc';
            }
            updateTable();
        }

        // =====================================================
        // MISE √Ä JOUR DU GRAPHIQUE
        // =====================================================
        
        // Cache pour les images des logos
        let logoImages = {};
        
        // Pr√©charger les images des logos via le proxy pour √©viter CORS
        async function preloadLogos(projects) {
            const promises = projects.map(p => {
                return new Promise((resolve) => {
                    if (!p.logo) {
                        resolve();
                        return;
                    }
                    
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = () => {
                        logoImages[p.name] = img;
                        addLog(`üñºÔ∏è Logo charg√©: ${p.name}`, 'success');
                        resolve();
                    };
                    img.onerror = () => {
                        addLog(`‚ö†Ô∏è Erreur chargement logo: ${p.name}`, 'warning');
                        resolve();
                    };
                    // Utiliser le proxy pour contourner CORS
                    img.src = `/api/logo?url=${encodeURIComponent(p.logo)}`;
                });
            });
            
            await Promise.all(promises);
        }
        
        // Variable pour stocker l'index du point survol√©
        let hoveredPoint = null;
        
        // Fonction pour calculer la distance entre deux points
        function getDistance(x1, y1, x2, y2) {
            return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        }
        
        // Fonction pour d√©tecter et r√©soudre les collisions statiques
        function resolveStaticCollisions(points, baseSize) {
            const minDistance = baseSize + 10; // Distance minimale entre les centres
            const offsets = points.map(() => ({ x: 0, y: 0 }));
            
            // Plusieurs passes pour r√©soudre les collisions
            for (let pass = 0; pass < 8; pass++) {
                for (let i = 0; i < points.length; i++) {
                    for (let j = i + 1; j < points.length; j++) {
                        const p1 = points[i];
                        const p2 = points[j];
                        
                        const x1 = p1.x + offsets[i].x;
                        const y1 = p1.y + offsets[i].y;
                        const x2 = p2.x + offsets[j].x;
                        const y2 = p2.y + offsets[j].y;
                        
                        const dist = getDistance(x1, y1, x2, y2);
                        
                        if (dist < minDistance && dist > 0) {
                            // Calculer le vecteur de s√©paration
                            const overlap = (minDistance - dist) / 2;
                            const dx = (x2 - x1) / dist;
                            const dy = (y2 - y1) / dist;
                            
                            // D√©caler les deux points
                            offsets[i].x -= dx * overlap * 0.6;
                            offsets[i].y -= dy * overlap * 0.6;
                            offsets[j].x += dx * overlap * 0.6;
                            offsets[j].y += dy * overlap * 0.6;
                        }
                    }
                }
            }
            
            return offsets;
        }
        
        // Plugin personnalis√© pour dessiner les logos avec anti-collision
        const logoPlugin = {
            id: 'logoPlugin',
            afterDatasetsDraw: function(chart) {
                const ctx = chart.ctx;
                const baseSize = 28;
                
                // Collecter tous les points des datasets 1 et 2
                let allPoints = [];
                
                chart.data.datasets.forEach((dataset, datasetIndex) => {
                    if (datasetIndex === 0) return;
                    const meta = chart.getDatasetMeta(datasetIndex);
                    
                    meta.data.forEach((point, index) => {
                        const data = dataset.data[index];
                        if (!data || !data.name) return;
                        
                        allPoints.push({
                            x: point.x,
                            y: point.y,
                            data: data,
                            datasetIndex: datasetIndex,
                            index: index,
                            logoImg: logoImages[data.name],
                            hasToken: datasetIndex === 1
                        });
                    });
                });
                
                // Calculer les d√©calages statiques pour √©viter les superpositions
                const staticOffsets = resolveStaticCollisions(allPoints, baseSize);
                
                // Dessiner tous les points avec leurs d√©calages
                allPoints.forEach((point, i) => {
                    const x = point.x + staticOffsets[i].x;
                    const y = point.y + staticOffsets[i].y;
                    const logoImg = point.logoImg;
                    const hasToken = point.hasToken;
                    const data = point.data;
                    
                    // V√©rifier si ce point est survol√©
                    const isHovered = hoveredPoint && 
                        hoveredPoint.datasetIndex === point.datasetIndex && 
                        hoveredPoint.index === point.index;
                    
                    // Taille avec animation (grossissement au hover)
                    const size = isHovered ? baseSize * 1.3 : baseSize;
                    
                    ctx.save();
                    
                    if (logoImg) {
                        // Dessiner un cercle de fond (bordure color√©e)
                        ctx.beginPath();
                        ctx.arc(x, y, size / 2 + 3, 0, Math.PI * 2);
                        ctx.fillStyle = hasToken ? 'rgba(59, 130, 246, 0.9)' : 'rgba(249, 115, 22, 0.9)';
                        ctx.fill();
                        
                        // Ombre port√©e au hover
                        if (isHovered) {
                            ctx.shadowColor = hasToken ? 'rgba(59, 130, 246, 0.5)' : 'rgba(249, 115, 22, 0.5)';
                            ctx.shadowBlur = 15;
                            ctx.shadowOffsetX = 0;
                            ctx.shadowOffsetY = 4;
                        }
                        
                        // Dessiner un cercle blanc derri√®re le logo
                        ctx.beginPath();
                        ctx.arc(x, y, size / 2 + 1, 0, Math.PI * 2);
                        ctx.fillStyle = '#ffffff';
                        ctx.fill();
                        
                        // Reset shadow pour le logo
                        ctx.shadowColor = 'transparent';
                        ctx.shadowBlur = 0;
                        
                        // Cr√©er un clip circulaire pour le logo
                        ctx.beginPath();
                        ctx.arc(x, y, size / 2, 0, Math.PI * 2);
                        ctx.clip();
                        
                        // Dessiner le logo
                        ctx.drawImage(logoImg, x - size / 2, y - size / 2, size, size);
                    } else {
                        // Fallback: dessiner un cercle color√© avec initiales
                        ctx.beginPath();
                        ctx.arc(x, y, size / 2 + 2, 0, Math.PI * 2);
                        ctx.fillStyle = hasToken ? 'rgba(59, 130, 246, 0.9)' : 'rgba(249, 115, 22, 0.9)';
                        ctx.fill();
                        
                        // Ombre port√©e au hover
                        if (isHovered) {
                            ctx.shadowColor = hasToken ? 'rgba(59, 130, 246, 0.5)' : 'rgba(249, 115, 22, 0.5)';
                            ctx.shadowBlur = 15;
                        }
                        
                        // Cercle int√©rieur blanc
                        ctx.beginPath();
                        ctx.arc(x, y, size / 2, 0, Math.PI * 2);
                        ctx.fillStyle = '#ffffff';
                        ctx.fill();
                        
                        // Reset shadow
                        ctx.shadowColor = 'transparent';
                        ctx.shadowBlur = 0;
                        
                        // Cercle int√©rieur color√©
                        ctx.beginPath();
                        ctx.arc(x, y, size / 2 - 2, 0, Math.PI * 2);
                        ctx.fillStyle = hasToken ? 'rgba(59, 130, 246, 0.2)' : 'rgba(249, 115, 22, 0.2)';
                        ctx.fill();
                        
                        // Initiales du projet
                        ctx.fillStyle = hasToken ? '#3b82f6' : '#f97316';
                        ctx.font = `bold ${isHovered ? 13 : 10}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        const initials = data.name.substring(0, 2).toUpperCase();
                        ctx.fillText(initials, x, y);
                    }
                    
                    ctx.restore();
                });
                
                // Dessiner les labels au-dessus des points (apr√®s tous les logos pour qu'ils soient au-dessus)
                allPoints.forEach((point, i) => {
                    const x = point.x + staticOffsets[i].x;
                    const y = point.y + staticOffsets[i].y;
                    const hasToken = point.hasToken;
                    const data = point.data;
                    const baseSize = 28;
                    
                    ctx.save();
                    ctx.fillStyle = hasToken ? '#3b82f6' : '#f97316';
                    ctx.font = 'bold 11px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';
                    ctx.fillText(data.name, x, y - baseSize / 2 - 8);
                    ctx.restore();
                });
            }
        };
        
        async function updateChart(regression) {
            const ctx = document.getElementById('scatterChart').getContext('2d');
            
            // D√©truire le graphique existant
            if (chart) {
                chart.destroy();
            }

            // Filtrer les projets valides pour le graphique
            const validProjects = projectsData.filter(p => p.annualRevenue > 0 && p.fdv > 0);
            
            // Pr√©charger les logos
            addLog('üñºÔ∏è Chargement des logos pour le graphique...', 'info');
            await preloadLogos(validProjects);
            
            // Pr√©parer les donn√©es
            const liveTokens = validProjects.filter(p => p.hasToken);
            const estimatedTokens = validProjects.filter(p => !p.hasToken);

            // Pr√©parer les donn√©es de la droite de r√©gression
            let regressionLine = [];
            if (regression) {
                // Trouver les min/max des revenus
                const revenues = validProjects.map(p => p.annualRevenue);
                const minRev = Math.min(...revenues);
                const maxRev = Math.max(...revenues);
                
                // Cr√©er des points pour la ligne
                const numPoints = 50;
                for (let i = 0; i <= numPoints; i++) {
                    const logRev = Math.log10(minRev) + (Math.log10(maxRev) - Math.log10(minRev)) * (i / numPoints);
                    const rev = Math.pow(10, logRev);
                    const fdv = estimateFDV(rev, regression);
                    regressionLine.push({ x: rev, y: fdv });
                }
            }

            // Configuration Chart.js
            chart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [
                        // Droite de r√©gression
                        {
                            label: 'R√©gression pond√©r√©e',
                            data: regressionLine,
                            type: 'line',
                            borderColor: 'rgba(249, 115, 22, 0.7)',
                            borderWidth: 2,
                            borderDash: [5, 5],
                            pointRadius: 0,
                            fill: false,
                            tension: 0,
                            order: 2
                        },
                        // Tokens live
                        {
                            label: 'Token Live',
                            data: liveTokens.map(p => ({
                                x: p.annualRevenue,
                                y: p.fdv,
                                name: p.name,
                                ratio: p.ratio,
                                logo: p.logo
                            })),
                            backgroundColor: 'transparent',
                            borderColor: 'transparent',
                            pointRadius: 18, // Hitbox pour le tooltip
                            pointHoverRadius: 20,
                            order: 1
                        },
                        // FDV estim√©es
                        {
                            label: 'FDV Estim√©e',
                            data: estimatedTokens.map(p => ({
                                x: p.annualRevenue,
                                y: p.fdv,
                                name: p.name,
                                ratio: p.ratio,
                                logo: p.logo
                            })),
                            backgroundColor: 'transparent',
                            borderColor: 'transparent',
                            pointRadius: 18,
                            pointHoverRadius: 20,
                            order: 0
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'nearest',
                        intersect: true
                    },
                    scales: {
                        x: {
                            type: 'logarithmic',
                            title: {
                                display: true,
                                text: 'Revenu Annuel (USD)',
                                font: { size: 14, weight: 'bold' }
                            },
                            ticks: {
                                callback: function(value) {
                                    // Afficher uniquement 1, 5, 10 et leurs puissances
                                    const log = Math.log10(value);
                                    const mantissa = value / Math.pow(10, Math.floor(log));
                                    if (Math.abs(mantissa - 1) < 0.01 || 
                                        Math.abs(mantissa - 5) < 0.01 || 
                                        Math.abs(mantissa - 10) < 0.01) {
                                        return formatUSD(value);
                                    }
                                    return '';
                                },
                                maxTicksLimit: 10
                            },
                            grid: {
                                color: 'rgba(0, 0, 0, 0.05)'
                            }
                        },
                        y: {
                            type: 'logarithmic',
                            title: {
                                display: true,
                                text: 'FDV (USD)',
                                font: { size: 14, weight: 'bold' }
                            },
                            ticks: {
                                callback: function(value) {
                                    const log = Math.log10(value);
                                    const mantissa = value / Math.pow(10, Math.floor(log));
                                    if (Math.abs(mantissa - 1) < 0.01 || 
                                        Math.abs(mantissa - 5) < 0.01 || 
                                        Math.abs(mantissa - 10) < 0.01) {
                                        return formatUSD(value);
                                    }
                                    return '';
                                },
                                maxTicksLimit: 10
                            },
                            grid: {
                                color: 'rgba(0, 0, 0, 0.05)'
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            enabled: true,
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleFont: { size: 14, weight: 'bold' },
                            bodyFont: { size: 12 },
                            padding: 12,
                            displayColors: false,
                            callbacks: {
                                title: function(context) {
                                    return context[0].raw.name || '';
                                },
                                label: function(context) {
                                    if (!context.raw.name) return '';
                                    return [
                                        `Revenu Annuel: ${formatUSD(context.raw.x)}`,
                                        `FDV: ${formatUSD(context.raw.y)}`,
                                        `Ratio: ${formatRatio(context.raw.ratio)}`
                                    ];
                                }
                            }
                        },
                        legend: {
                            display: false
                        },
                        datalabels: {
                            display: false // D√©sactiv√© car on dessine les labels dans logoPlugin
                        }
                    },
                    onHover: function(event, elements) {
                        const canvas = event.native.target;
                        if (elements.length > 0 && elements[0].datasetIndex > 0) {
                            canvas.style.cursor = 'pointer';
                            const newHovered = {
                                datasetIndex: elements[0].datasetIndex,
                                index: elements[0].index
                            };
                            if (!hoveredPoint || hoveredPoint.datasetIndex !== newHovered.datasetIndex || hoveredPoint.index !== newHovered.index) {
                                hoveredPoint = newHovered;
                                chart.draw();
                            }
                        } else {
                            canvas.style.cursor = 'default';
                            if (hoveredPoint !== null) {
                                hoveredPoint = null;
                                chart.draw();
                            }
                        }
                    }
                },
                plugins: [ChartDataLabels, logoPlugin]
            });
        }

        // =====================================================
        // INITIALISATION
        // =====================================================
        
        // Charger les donn√©es au d√©marrage
        document.addEventListener('DOMContentLoaded', function() {
            loadAllData();
            
            // Actualisation automatique toutes les 24h
            setInterval(loadAllData, 24 * 60 * 60 * 1000);
        });
    </script>
</body>
</html>
